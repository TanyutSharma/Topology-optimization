
// Standard shape optimization

// Force is slightly offsetted from center while targeted displacement is at the center.


real Lx = 2.0;
real Ly = 1.0;
real nymesh = 160.0 / 2;
real nxmesh = 100.0 / 2;

//Position of force
real xc = Lx / 2;
real yc = Ly / 3;

real F = 1.0;
real r = 0.5;

real alpha = 0.12;
real dt = 0.0;

border a(t = 0, Ly) {x = 0; y = Ly - t; label = 1;}
border b(t = 0, Lx) {x = t; y = 0; label = 2;}
border c(t = 0, Ly) {x = Lx; y = t; label = 3;}
border d(t = 0, Lx) {x = Lx - t; y = Ly; label = 4;}

mesh Th = buildmesh(a(nymesh) + b(nxmesh) + c(nymesh) + d(nxmesh));

fespace Vh2d(Th, P1);

Vh2d u, v, p, pv;

real h0 = 0.5;
Vh2d h = h0;
Vh2d hr;

real minh = 0.04, maxh = 2.0;
real hfrac = int2d(Th) (h0);
real l0 = 0.0;
real l1 = 1.0;
real lmid = 0.5;
real lerr = 0.001;
real proj0 = 0.0, proj1 = 0.0, projmid = 0.0;

func f = F * exp(-((x - xc) ^ 2 + (y - yc) ^ 2) / (2.0 * r * r));
int maxiter = 200;

real D = 200.0;

//Position of displacement.
real xd = Lx / 2;
real yd = Ly / 2;
func d0 = D * exp(-((x - xd) ^ 2 + (y - yd) ^ 2) / (2.0 * r * r * 0.0002));

real target = 0.0;

real epsi = 0.02;
problem regularization(hr, v)
	= int2d(Th) (
		epsi ^ 2 * (dx(hr) * dx(v) + dy(hr) * dy(v)) + hr * v
	)
	- int2d(Th) (
		h * v
	);

while(maxiter > 0) {
	solve Membrane (u, v)
		= int2d(Th) (
			h * (dx(u) * dx(v) + dy(u) * dy(v))
		)
		- int2d(Th) (
			f * v
		)
		+ on(1, u = 0)
		+ on(2, u = 0)
		+ on(3, u = 0)
		+ on(4, u = 0);

	solve Adjointe (p, pv)
		= int2d(Th) (
			h * (dx(p) * dx(pv) + dy(p) * dy(pv))
		)
		+ int2d(Th) (
			(u - d0) * pv
		)
		+ on(1, p = 0)
		+ on(2, p = 0)
		+ on(3, p = 0)
		+ on(4, p = 0);

	Vh2d dJ = (dx(p) * dx(u) + dy(p) * dy(u));

	//dt = alpha / max(h[].max, -h[].min);
	dt = alpha;

	h = h - dt * dJ;

	proj0 = int2d(Th) (max(minh, min(maxh, (h + l0))));
	proj1 = int2d(Th) (max(minh, min(maxh, (h + l1))));

	while(proj0 > hfrac) {
		l0 -= 0.1;
		proj0 = int2d(Th) (max(minh, min(maxh, (h + l0))));
	}

	while(proj1 < hfrac) {
		l1 += 0.1;
		proj1 = int2d(Th) (max(minh, min(maxh, (h + l1))));
	}

	while((l1 - l0) > lerr) {
		lmid = 0.5 * (l0 + l1);
		projmid = int2d(Th) (max(minh, min(maxh, (h + lmid))));

		if(projmid < hfrac) {
			l0 = lmid;
			proj0 = projmid;
		} else {
			l1 = lmid;
			proj1 = projmid;
		}
	}

	h = max(minh, min(maxh, (h + lmid)));

	regularization;
	h = hr;

	target = int2d(Th) ( 0.5 * (u - d0) * (u - d0) );
	cout << endl << "                  TARGET  ->  " << target << "    ITERATION  ->  " << maxiter << endl << endl;

	plot(h, fill = true, grey = true);

	maxiter--;
}

plot(u, wait = 1, fill = 1, grey = true);